//제목 : 토너먼트
//목적 : 지민과 한수가 대결하는 라운드 숫자를 확인
//조건 : 참가자의 수는 10만 이하

/* 아이디어 :
1.참가자의 수가 짝/홀일 경우로 나누어서 생각
1.1 짝/홀이 나뉘고, 지민과 한수가 각각 짝/홀인 경우도 생각

--짝수인 경우--
번호 : 12 34 56 78 ... 2N-1 2N
참가자 : 짝->짝->짝...
규칙 :
1번 세트의 2*1-1,2*1 (2^0,2^1) 은 이기면 2*1-1번
2번 세트의 2*2-1,2*2 (2^1+1~2^1+2) 는 이기면 2*1번
3번 세트의 2*3-1,2*3 (2^2+1~2^2+2) 은 이기면 2*2-1번
...
즉 하위 라운드의 2k-1,2k 세트 참가자는 상위 라운드의 k세트 앞,뒤
--홀수인 경우--
번호 :12 34 56 ... 2N-1
참가자수 : 홀->홀->홀->
규칙 :마찬가지로 무한반복인데 마지막 놈은 계속 부전승
마지막 2^n+1은 2^n-1+1

*/

/*구현 :
나누기 2를 처리하는 방법
1. %2 사용
2. LSB가 0이면 나머지 없음, 1이면 나머지 있음


1. 두명 싸우는지 확인 필요
->싸우느냐 안싸우느냐는 같은 세트(k)를 공유하느냐 안하느냐
2. 싸우면 cnt 출력
3. 안싸우면 cnt늘리고 다음 라운드로 번호배정
(번호배정 규칙은 위에서)

*/

/*느낀점 : 
1. 정수, 나누기 문제는 숫자 +1차이로 틀릴수있으므로 논리를 확실히 검증해야 함
2.현재 라운드와 미래 라운드 확실한 구분 필요
3. C++에서 원하는 밑을 가진 로그 쓰는법 확실히 할 것
->기본제공은 자연로그/상용로그. 공식 이용해서 바꿔야 함
(log2(x) = log10(x)/log10(2)...인데, 이거 실수라서 굉장히 위험할듯)
*/
#include <iostream>

using namespace std;

int N;
int kim, yim;
int cnt = 1;

bool isFight;
void input()
{
	cin >> N >> kim >> yim;
}

int main()
{
	input();

	if (N & 1 == 0) { //N = 짝
		while (N > 2) { 
			//겨루는지 확인
			int yim_set = (yim + 1) / 2;
			int kim_set = (kim + 1) / 2;
			if (yim_set == kim_set) {
				isFight = true;
				break;
			}
			else {
				cnt++;
				N /= 2;
				yim = yim_set;
				kim = kim_set;
			}
		}
	}
	else { //N = 홀
		//부전승자 있는지 파악
		if (kim == N || yim == N) { 
			while (N > 2) {
				N /= 2+1;
				cnt++;
			}
		}

		else { //아무도 아님
			while (N > 2) { //겨루기 확인
				int yim_set = (yim + 1) / 2;
				int kim_set = (kim + 1) / 2;
				if (yim_set == kim_set) {
					isFight = true;
					break;
				}
				else {
					cnt++;
					N = N/2+1;
					yim = yim_set;
					kim = kim_set;
				}
			}
		}
		
	}
	if(isFight) cout << cnt;
	else cout << -1;
}