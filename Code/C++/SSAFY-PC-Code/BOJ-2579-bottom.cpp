//제목 : 계단 오르기
//목적 : 계단을 올라서 얻을 수 잇는 점수의 최댓값
/*조건 :
1. 계단은 최대 300개 -> 즉 트리로 따지면 깊이가 100이 넘어감 -> DP
2. 0은 바닥으로, 계단으로 취급하지 않는다. 즉 첫번째와 두번째는 연달아서 밟을 수 있다.
3. 마지막 계단은 반드시 밟아야 한다. 즉 N-1에서 2칸 올라가는 것은 허용하지 ㅇ낳는다.
*/

/*아이디어 : 바텀업 방식 사고를 해보자
1. 1번계단 초기화
2. 2번계단부터 시작
3. 2번은 1번에서 1칸 올라오는 거 vs 0에서 2칸 올라오는 거
4. 3번은 2번에서 1칸 올라오는 거 vs 1번에서 2칸 올라오는거
5. 그럼 이때 연속 체크는 어떻게? ->
*/

/*아이디어 :
k번째 계단으로 오르는 최대값 : k-1에서 1칸 올라오는 최대값 , k-2에서 2칸 올라오는 최대값
중 더 큰 것
*/
#include <iostream>
#include <algorithm>

using namespace std;

int N;
int score[301];
int dp[301][3]; //각 칸을 행으로, 전의 칸으로부터 1칸 올라오는건 1열에, 두칸 전으로부터 2칸 올라오는건 2열에


int main()
{
	//입력 받기
	cin >> N;
	for (int i = 1; i <= N; ++i)
		cin >> score[i];

	//dp초기화
	dp[1][1] = score[1]; //0번째 계단
	dp[1][2] = score[1];
	dp[2][1] = dp[1][1] + score[2];
	dp[2][2] = score[2];

	//dp[N][0] = find_max(N, 0);
	//dp[N][1] = find_max(N, 1);
	for (int i = 3; i <= N; ++i)
	{
		//밑의 계단부터 채워 올라감
		//3칸 연속 못 올라가는건, N-2번째 계단부터 고려함으로서 해결

		dp[i][1] = dp[i - 1][2] + score[i];
		dp[i][2] = max(dp[i - 2][1] + score[i], dp[i - 2][2] + score[i]);
	}

	/*for (int i = 1; i <= N; ++i)
		cout << score[i] << '\n';*/
	int result = max(dp[N][1], dp[N][2]);
	cout << result;
}

