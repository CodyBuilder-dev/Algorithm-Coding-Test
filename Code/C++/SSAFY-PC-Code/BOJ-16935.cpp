//제목 : 배열 돌리기 3
//목적 : 주어진 규칙에 따라 배열을 돌리는 연산을 한다
/*조건 :
시간복잡도 : 배열의 크기는 최대 100x100,
반전연산은 1번당 최대 배열의 절반 훑기
회전연산은 그냥 새로 배열 만든후 인덱스 표기만 바꾸기
5,6번 연산도 마찬가지
즉, 최대 10^3 * 10^4 는 괜찮긴 할듯

공간복잡도 : 배열에 저장된 값은 10^8이하이므로 표현범위는 ㄱㅊ
*/

/*아이디어 : 값을 직접 옮기지 말고, 포인터로 위치를 바꾸자!
1. 각 연산을 구현해두고, 입력 받을때마다 수행
2. 여기서 배열의 모든 정보를 다 움직이지 말고,
4구간으로 나눠서 상태만 변화
3. 더 줄이는 법은, 반전 2번이면 그대로니 놔두기
4. 보니까 다 짝수일때만인데 홀수는 어떡하지? 일단 풀기
*/

#include <iostream>
#include <algorithm>

using namespace std;

int N, M;
int block[2][2]; //0,0은 왼쪽위, 1,1은 오른쪽 아래. 01은 위쪽 반틈, 23은 아래쪽 반틈

int board[100][100];
int partition[4][50][50];

//모든연산을 다 1개 함수로 통일
void execute(int op)
{
	switch (op) {
	case 1: //상하반전
		for (int i = 0; i < N / 2; ++i)
			for (int j = 0; j < M; ++j)
				swap(board[i][j], board[N - i][j]);

	case 2: //좌우반전

	case 3: //시계90도
	case 4: //반시계 90도
	case 5: //부분 시계 90도
	case 6: //부분 반시계 90도

	}
}
