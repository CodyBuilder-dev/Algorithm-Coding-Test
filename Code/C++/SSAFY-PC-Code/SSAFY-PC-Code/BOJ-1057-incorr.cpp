//제목 : 토너먼트
//목적 : 지민과 한수가 대결하는 라운드 숫자를 확인
//조건 : 참가자의 수는 10만 이하

/* 아이디어 : 
1.참가자의 수가 짝/홀일 경우로 나누어서 생각
1.1 짝/홀이 나뉘고, 지민과 한수가 각각 짝/홀인 경우도 생각

--짝수인 경우--
번호 : 12 34 56 78 ... 2N-1 2N 
참가자 : 짝->짝->짝...
규칙 : 
1번 세트의 2*1-1,2*1 (2^0,2^1) 은 이기면 2*1-1번
2번 세트의 2*2-1,2*2 (2^1+1~2^1+2) 는 이기면 2*1번
3번 세트의 2*3-1,2*3 (2^2+1~2^2+2) 은 이기면 2*2-1번
...

--홀수인 경우--
번호 :12 34 56 ... 2N-1
참가자수 : 홀->홀->홀->
규칙 :마찬가지로 무한반복인데 마지막 놈은 계속 부전승
마지막 2^n+1은 2^n-1+1

*/

/*구현 :
나누기 2를 처리하는 방법
1. %2 사용
2. LSB가 0이면 나머지 없음, 1이면 나머지 있음
*/

//주의점 : 숫자 +1차이로 틀릴수있으므로 논리를 확실히 검증해야 함
//현재 라운드와 미래 라운드 확실한 구분 필요
#include <iostream>

using namespace std;

int N;
int kim, yim;

void input()
{
	cin >> N >> kim >> yim;
}

int main()
{
	input();
	/*흐름
	1. 두명 싸우는지 확인 필요
	2. 싸우면 cnt 출력
	3. 안싸우면 cnt늘리고 다음 라운드로 번호배정
	(번호배정 규칙은 위에서)
	*/

	int cnt = 1;
	if (N & 1 == 0) { //N = 짝
		while (N / 2 > 0) {
			//겨루는지 확인 구문 필요
			if (yim / 2 - kim / 2 == 1 || yim / 2 - kim / 2 == -1)
				break;

			kim = (kim + 1) / 2;
			yim = (yim + 1) / 2;
			
			N = N / 2;
			cnt++;

		}
	}
	else { //N = 홀
		while (N / 2 + 1 > 0) {
			if(kim == N){
				if (yim % 2 == 0) { //오른쪽
					kim = (kim / 2) + 1;
					yim = (yim) / 2;
				}
		
				else  //왼쪽
				
			}
			else if (yim == N) {
				
				if (yim - kim == 1 || kim - yim == 1)
					break;

				kim = (kim + 1) / 2;
				yim = (yim/2) +1;
			}
			else {
				if (yim / 2 - kim / 2 == 1 || yim / 2 - kim / 2 == -1)
					break;

				kim = (kim + 1) / 2;
				yim = (yim + 1) / 2;
				
				
			}

			N = N / 2 + 1;
			cnt++;

		}
	}
	cout << cnt;

}