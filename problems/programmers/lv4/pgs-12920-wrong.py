"""
제목 : 선입 선출 스케쥴링

아이디어 : 시간의 흐름을 직접 시뮬레이션?
- 가능한 시간의 범위가 너무 크다 O(10^4 * 5*10^4)
- 문제에서 원하는 답에 '시간'에 관한게 없다
-> 굳이 할 필요 없음


아이디어 : 특정 시간에 작업완료된 작업의 총량 확인?
- 코어는 작업시간의 배수 시간마다 1개의 작업을 완료한다
    - 속도가 1인 코어는 1,2,3,4...
    - 속도가 2인 코어는 2,4,6...
- 앞에서부터 더해가면서 n보다 커지는 시점 찾는다
-> '작업완료'가 아니라 '작업할당'시점에 대해 묻는 문제이므로,
접근법 자체는 좋음에도 불구하고 목표하는 변수를 잘못 설정해 틀림


아이디어 : 우선순위 큐를 이용해, 일에다가 코어를 할당한다
- 몇초에 어떤 코어가 어떤 일을 할지 따지지 말고, 그냥 일을 앞에서부터 코어에 할당하면 된다
    - 남은 일은 정확히 몇초일진 몰라도 아마 제일 빨리 끝나는 다음 코어가 할 것이다
    - 다음으로 제일 빨리 나오는 코어가 누군지만 알면 된다
- 우선순위 큐를 이용하면 구현할 수 있다
    - 작업 번호를 인덱스로 갖는 배열을 만든다
    - 코어를 우선순위 큐에 넣는다
    - 작업 배열을 앞에서부터 탐색하며, 우선순위 큐의 가장 앞에 있는 코어를 꺼내서 넣는다?
-> 우선순위 큐 내의 우선순위 관리가 쉽지 않음(코어별 남은 대기시간 관리가 어려움)
-> 기각
"""

def solution(n, cores):
    available_cores = [[] for i in range(n+1)]

    for i, core in enumerate(cores):
        for j in range(0,n+1,core):
            available_cores[j].append(i)
    return available_cores

    sum = 0
    i = 0
    while sum < n:
        sum += len(available_cores[i])
        i+=1
    return available_cores[i][-1-(sum-n)]

print(solution(6,[1,2,3]))
print(solution(5,[4540, 6383, 8674, 2699]))