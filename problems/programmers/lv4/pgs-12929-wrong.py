"""
제목 : 올바른 괄호의 개수

아이디어 : 단순무식하게 모든 경우의 수를 만든 후, 해당 경우가 올바른 괄호인지 확인한다
(1) 괄호 만들기
- 그냥 (((... )))을 배열만 하면된다
- n개씩 중복이 있는 2n개의 배열 방법이므로, 2n!/n!/n! = 4천만가지가 된다
    - 문제에서 친절하게 14쌍까지 제한해줘서 4천만가지이다
    - 단 한쌍만 늘어나 15쌍이 되더라고 1억가지가 넘어 시간초과에 걸린다

(2) 올바른 괄호 판정
- 스택에 넣거나, 숫자를 세서 확인하면 된다

-> 기각 : 너무 큼

아이디어 : 괄호의 구조를 잘 본다
(1) 1쌍인 경우 : ()
(2) 2쌍인 경우 : ()() or (())
(3) 3쌍인 경우 : ()()() or (())() ()(()) (()()) or ((()))
(4) 4 : ()()()() or (())(()) (()()()) (()())() ()(()()) ()(())()

- 점화식?
    - 가장 바깥쪽에 하나 싸고 ㅣ존걸 집어넣는 경우 : C(n-1)
    - 기존거의 안쪽에 하나 집어넣는 경우 : (C(n-1)-1)
- 괄호의 깊이 기반?
    - 1쌍 : 1
    - 2쌍 : 1 + 1
    - 3쌍 : 1 + 2개로 깊이2 만들고 1개로 깊이1 만드는 것
              + 3개로 깊이2 만드는 것
                    + 1
    - 4쌍 : 1 + 2개로 깊이2만들고 2개로 깊이1 민드는것
              + 3개로 깊이2만들고 1개로 깊이1 만드는 것
              + 4개로 깊이2만드는 것
                    + 3개로 깊이3만드는것
                    + 4개로 깊이3만드는것
                        + 1
    - 5쌍 : 1 + 2개
              + 3개
              + 4개
              + 5개
                    +3개로 깊이3 ,2개로 깊이 1,2
                    +4개로 깊이3
                    +5개로 깊이3
    n개로 x깊이를 만드는 경우의 수를 C(n,x)라 하자
    d(n) = C(n,1) + C(n,2) + C(n,3) .. + C(n,n)
        = 1 + C(n-1,2)*C(1,1)*2
            + C(n-2,2)*C(2,1)+2 + C(n-2,2)*C(2,2)*2
            + C(n-3,2)*C(3,1)*2 + C(n-3,2)*C(3,2)*2
            + ...
                +C(n-1,3)*C(1,1)
                +C(n-2,3)*C(2,1) + C(n-2,3)*C(2,2)
                +C(n-3,3)*C(3,1) + C(n-3,3)*C(3,2) + C(n-3,3)*C(3,3)
        = (일반식을 세우기가 매우 힘듬)
"""
from math import ceil

def solution(n):
    if n == 1 : return 1
    d = [[0]*(n+1) for _ in range(n+1)]

    # 초기값
    d[1][0] = 0
    d[1][1] = 1
    d[2][0] = 0
    d[2][1] = 1
    d[2][2] = 1

    for i in range(3,n+1):
        for j in range(1,i+1):
            if j == 1 or j == i: d[i][j] = 1
            else:
                for k in range(j, i+1):
                    temp = 0
                    for l in range(1,min(i-k+1,j+1)):
                        if i-k == l: temp += d[i-k][l]
                        else: temp += 2*d[i-k][l]
                    d[i][j] += d[k][j]*temp

    return sum(d[n])

answer = [1,1,2,5,14,42,132,429,1430,4862,16796,58786,208012,742900,2674440]

for i in range(1,15):
    print(solution(i),answer[i])