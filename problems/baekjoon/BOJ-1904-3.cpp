//제목 : 01타일
//목표 : 00, 1 두가지 타일이 있을 때, 두 타일로 만들 수 있는 길이가 N인 모든 경우의 수
//조건 : N은 최대 100만

/*아이디어 :
길이 N인 경우의 수는, 00타일을 m개, 1타일을 n개 선택하는 겨웅의 수다
즉 N = 2m+n을 만족하는 m,n을 찾는 것
(m,n)순서쌍에 대해, 같은것이 있는 것을 배치하는 순열은
(m+n)!/m!/n! ->계산 ㅂㄱㄴ
->동적계획법 스타트

메모이제이션? 잘 모르겠음
점화식? 이거는 진짜 관찰하던지 해서 직접 찾아야 함
관찰 -> O(N)은 O(N-1)에 1을 껴넣은거 + O(N-2)에 00을 껴넣은 거
결국 피보나치?!
(피보나치인 이유 : 끝이 00으로 끝나느냐, 1로 끝나느냐 중에 하나임)

*/

/*구현 : 'n으로 나눈 나머지를 출력하여라' 라는 문구는
1. 결과값이 엄청나게 클 것이고
2. 따라서 DP를 사용해야 하는 문제일 것이고
3. 끝난후 한번에 나누는게 아니라 계속해서 나누면서 연산해도 괜찮다는 의미
*/

#include <iostream>

using namespace std;

int N;
int caseCnt[1000001];

int main()
{
	cin >> N;
	caseCnt[1] = 1;
	caseCnt[2] = 2;
	for (int i = 3; i <= N; ++i) {
		caseCnt[i] = (caseCnt[i - 1]+caseCnt[i - 2])%15746;
	}
	cout << caseCnt[N];
}